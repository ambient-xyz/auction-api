use crate::error::AuctionError;
use crate::instruction::IpAddr;
use crate::{InstructionAccounts, PUBKEY_BYTES};
use bytemuck::{Pod, Zeroable};

/// PlaceBid instruction
///
/// Creates a concealed [`bid`] account for an associated auction.
///
/// # Account References:
///
/// 0. `[WRITE, SIGNER]` Funding account
/// 1. `[WRITE]` New bid account
/// 2. `[WRITE]` Auction account
/// 3. `[READ]` System program
#[derive(Debug, Clone)]
#[repr(C)]
pub struct PlaceBidAccounts<'a, T> {
    pub payer: &'a T,
    pub bid: &'a T,
    pub auction: &'a T,
    pub system_program: &'a T,
}

impl<'a, T> TryFrom<&'a [T]> for PlaceBidAccounts<'a, T> {
    type Error = AuctionError;
    fn try_from(accounts: &'a [T]) -> Result<Self, Self::Error> {
        let [payer, bid, auction, system_program] = accounts.as_ref() else {
            return Err(Self::Error::NotEnoughAccounts);
        };
        Ok(Self {
            payer,
            bid,
            auction,
            system_program,
        })
    }
}

impl<'a, T> InstructionAccounts<'a, T> for PlaceBidAccounts<'a, T> {
    fn iter(&'a self) -> impl Iterator<Item = &'a T> {
        std::iter::once(self.payer)
            .chain(std::iter::once(self.bid))
            .chain(std::iter::once(self.auction))
            .chain(std::iter::once(self.system_program))
    }
    fn iter_owned(&self) -> impl Iterator<Item = T>
    where
        T: Clone,
    {
        self.iter().cloned()
    }
}
#[derive(Pod, Clone, Copy, Zeroable, PartialEq, Eq, Debug)]
#[repr(C)]
pub struct PlaceBidArgs {
    /// The committed hash that conceals the bid price until the reveal phase.
    /// Generated by hashing together a random [u8;32] seed and the little-endian
    /// byte representation of the price_per_output_token.
    /// This hash is used to verify the revealed bid matches the original commitment.
    pub price_hash: [u8; 32],
    /// The authority of the bid: later used to collect funds
    pub authority: [u8; PUBKEY_BYTES],
    /// The IP Address to contact this inference host
    pub ip: IpAddr,
    /// The port to contact this inference host
    pub port: u16,
    pub encryption_node_public_key: [u8; PUBKEY_BYTES],
    /// Padding to make sure things align properly
    pad: [u8; 10],
}

impl PlaceBidArgs {
    pub fn new(
        price_hash: [u8; 32],
        authority: [u8; PUBKEY_BYTES],
        ip: IpAddr,
        port: u16,
        public_key: Option<[u8; PUBKEY_BYTES]>,
    ) -> Self {
        Self {
            price_hash,
            authority,
            ip,
            port,
            encryption_node_public_key: public_key.unwrap_or_default(),
            pad: [0; 10],
        }
    }
}
